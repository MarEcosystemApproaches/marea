#' Download satellite ocean colour data
#'
#' Downloads satellite ocean colour bloom metrics generated by the SOPhyE team at DFO from the CIOOS Atlantic ERDDAP (see "Details" for coordinate boundaries and years for which data is available). Can be used to download other datasets if the dataset ID and ERDDAP URL is specified.
#' 
#' SOPhyE satellite ocean colour spring bloom metrics:
#' 42-76 degrees west, 39-66 degrees north
#' 1998-2024 (will be updated annually)
#' Note: Years should be formatted as e.g. "1998-01-01T00:00:00Z" in the "timelim" argument
#' 
#' The satellite bloom metrics downloaded by this function are 4.64 km resolution and include all the variables in the product at a lower level of quality control. In contrast, the satellite_ocean_colour variable available in the marea package is fully quality-controlled and ready to use, excludes the two quality indicator layers (NRMSE_bloom and percent_dineof), and has been resampled to 0.1 degree resolution (it is recommended to use the mean or median of pixel values within this range when working with the original data, so this is the appropriate resolution to use).
#' 
#' @param dataset_id Dataset ID (default is "bio_remote_sensing_occci_nwa_poly4_spring_bloom", the satellite ocean colour spring bloom metrics generated by the SOPhyE group at DFO)
#' @param erddap_url URL for the ERDDAP server where the data is located (default is "https://cioosatlantic.ca/erddap/", the CIOOS Atlantic ERDDAP server)
#' @param variables vector of variable names to download (default is the vector of variables in the spring bloom metrics dataset)
#' @param xlim Minimum and maximum longitude (if NULL, downloads the full range of longitudes)
#' @param ylim Minimum and maximum latitude (if NULL, downloads the full range of latitudes)
#' @param timelim Start and end datetime string in format "YYYY-MM-DDT00:00:00Z" (if NULL, downloads the full time series)
#'
#' @return Dataframe with columns longitude, latitude, time, and the selected variables
#' @export
#'
#' @examples
#' \dontrun{
#' df <- get_erddap_data(variables=c("t_start","t_duration"), timelim=c("2023-01-01T00:00:00Z","2024-01-01T00:00:00Z"))
#' r <- stars::st_as_stars(df, dims = c("longitude","latitude","time"))
#' plot(r)
#' }
get_erddap_data <- function(dataset_id = "bio_remote_sensing_occci_nwa_poly4_spring_bloom", erddap_url = "https://cioosatlantic.ca/erddap/", variables = c("t_start", "t_duration", "amplitude_real", "magnitude_real", "annual_mean", "NRMSE_bloom", "percent_dineof"), xlim = NULL, ylim = NULL, timelim = NULL) {

  # get the dataset info from the server
  dataset_info <- rerddap::info(dataset_id, url=erddap_url)
  
  # check if requested variable names don't match the ones in the dataset
  if (any(!(variables %in% dataset_info$variables$variable_name))) {
    stop("One or more variables requested do not match variables in dataset (",paste0(dataset_info$variables$variable_name,collapse=", "),")")
  }
  
  # get dataset boundaries from erddap
  di_xlim <- as.numeric(strsplit(dataset_info$alldata$longitude$value[3],split=", ")[[1]])
  di_ylim <- as.numeric(strsplit(dataset_info$alldata$latitude$value[3],split=", ")[[1]])
  di_timelim <- format(lubridate::as_datetime(as.numeric(strsplit(dataset_info$alldata$time$value[3],split=", ")[[1]])),"%Y-%m-%dT00:00:00Z")
  
  # correct requested boundaries if they're outside the range of available data
  if (is.null(xlim)) {
    xlim <- di_xlim
  } else {
    if (xlim[1]<di_xlim[1] | xlim[2]>di_xlim[2]) {
      warning("Requested longitudes are outside the range of available data (",paste(di_xlim,collapse=" to "),")")
      xlim <- c(max(c(xlim[1],di_xlim[1])), min(c(xlim[2],di_xlim[2])))
    }
  }
  if (is.null(ylim)) {
    ylim <- di_ylim
  } else {
    if (ylim[1]<di_ylim[1] | ylim[2]>di_ylim[2]) {
      warning("Requested latitudes are outside the range of available data (",paste(di_ylim,collapse=" to "),")")
      ylim <- c(max(c(ylim[1],di_ylim[1])), min(c(ylim[2],di_ylim[2])))
    }
  }
  if (is.null(timelim)) {
    timelim <- di_timelim
  } else {
    if (timelim[1]<di_timelim[1] | timelim[2]>di_timelim[2]) {
      warning("Requested time series limits are outside the range of available data (",paste(di_timelim,collapse=" to "),")")
      timelim <- c(max(c(timelim[1],di_timelim[1])), min(c(timelim[2],di_timelim[2])))
    }
  }
  
  # download the data from the server
  # note: there is an issue with the fields="all" argument of griddap when the variables are not in alphabetical order, so you need to download the variables individually and then bind them together
  df <- lapply(variables, function(v) {
    rerddap::griddap(dataset_info, latitude=ylim, longitude=xlim, time=timelim, fields=v)$data
  }) %>%
    Reduce(function(d1,d2) dplyr::left_join(d1,d2,by=c("longitude","latitude","time")), .) %>%
    dplyr::mutate(time=lubridate::as_datetime(time))
  
  return(df)
  
}
